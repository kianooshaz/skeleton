# AI Coding Instructions for Skeleton Project

## Project Overview
This is a Go microservices project using clean architecture principles with domain-driven design. The project uses Echo web framework, PostgreSQL for data persistence, Google Wire for dependency injection, and structured logging with slog.

## Architecture Patterns

### Directory Structure
- `cmd/` - Application entry points
- `foundation/` - Shared foundational packages (config, logging, database, etc.)
- `services/` - Domain services organized by business context
- `internal/` - Private application code (containers, web handlers)
- `docs/` - Documentation

### Service Structure Pattern
Each service follows this structure:
```
services/{domain}/{subdomain}/
├── proto/          # Domain models and interfaces
├── service/        # Business logic implementation  
├── persistence/    # Data access layer
└── queries/        # SQL queries
```

## Coding Standards

### Package Naming
- Use lowercase, single words when possible
- Proto packages: `{domain}proto` (e.g., `userproto`, `usernameproto`)
- Service packages: `{domain}service` (e.g., `userservice`, `usernameservice`)
- Persistence packages: Use `persistence` consistently

### Error Handling
- Use domain-specific errors defined in `foundation/derror/errors.go`
- Error codes follow pattern: `{category}{subcategory}{specific}` (e.g., `100301` for username invalid)
- Always wrap errors with context: `fmt.Errorf("description: %w", err)`
- Use error codes as string literals: `errors.New("100301")`

### Logging Standards
- Use structured logging with `slog` package
- Logger initialization with service context:
```go
serviceLogger := *logger.With(
    slog.Group("package_info",
        slog.String("module", "username"),
        slog.String("service", "account"),
    ),
)
```
- Log levels: debug, info, warn, error
- Use key-value pairs for structured data
- Example: `logger.Info("Application started successfully")`
- Error logging: `slog.Error("message", "error", err)`

### Configuration
- Use YAML for configuration files
- Configuration structs with validation tags:
```go
type Config struct {
    Name string `yaml:"name" validate:"required"`
    Port int    `yaml:"port" validate:"min=1,max=65535"`
}
```
- Use koanf library for config loading
- Environment variable override: `CONFIG_PATH`

### Dependency Injection (Wire)
- Use Google Wire for dependency injection
- Define provider functions for each component
- Group related providers in Wire sets
- Config extraction pattern:
```go
func ProvideServiceConfig(cfg *AppConfig) ServiceConfig { 
    return cfg.Service 
}
```

### Database Integration
- Use PostgreSQL with pgx driver
- SQL queries in separate `.sql` files under `queries/` directory
- Connection through foundation postgres package
- Transaction support through session package

### Data Models

#### Proto Package (Domain Models)
- Define domain entities and interfaces
- Use proper JSON and BSON tags
- Include validation tags where appropriate
- Service interfaces define business operations
```go
type User struct {
    ID        uuid.UUID `json:"id" bson:"id"`
    Name      string    `json:"name" bson:"name"`
    CreatedAt time.Time `json:"created_at" bson:"created_at"`
}

type UserService interface {
    Create(ctx context.Context, req CreateRequest) (User, error)
    Get(ctx context.Context, id uuid.UUID) (User, error)
}
```

#### Nullable Types
- Use `foundation/types.Nullable[T]` for optional fields
- Provides proper JSON marshaling/unmarshaling
- SQL null handling built-in
```go
Username types.Nullable[string] `query:"username"`
```

#### Pagination and Ordering
- Use `foundation/pagination` for list responses
- Use `foundation/order` for sorting
- Standard pattern:
```go
type ListRequest struct {
    pagination.Page
    order.OrderBy
}
type ListResponse pagination.Response[Entity]
```

### HTTP/REST API

#### Echo Framework Setup
- Use Echo v4 with proper middleware configuration
- Enable recovery, request ID, security headers
- CORS and rate limiting configurable
- Custom error handling with domain errors

#### Request/Response Patterns
- Request structs with proper validation tags
- Query parameters use `query:` tags
- JSON body parameters use `json:` tags
- Response structs match domain models

#### Middleware
- Request ID tracking with session package
- User ID extraction from headers
- Rate limiting with Redis (configurable)
- CORS handling

### Service Implementation

#### Constructor Pattern
```go
func New(cfg Config, db *sql.DB, logger *slog.Logger) ServiceInterface {
    serviceLogger := *logger.With(
        slog.Group("package_info",
            slog.String("module", "service_name"),
            slog.String("service", "domain_name"),
        ),
    )
    
    return &Service{
        config: cfg,
        logger: serviceLogger,
        storage: &persistence.Storage{Conn: db},
    }
}
```

#### Business Logic
- Separate business logic from persistence
- Use interfaces for storage dependencies
- Context propagation for all operations
- Proper error handling and logging

#### Storage Interface Pattern
```go
type Storer interface {
    Create(ctx context.Context, entity Entity) error
    Get(ctx context.Context, id uuid.UUID) (Entity, error)
    List(ctx context.Context, req ListRequest) ([]Entity, error)
    Update(ctx context.Context, entity Entity) error
    Delete(ctx context.Context, id uuid.UUID) error
}
```

## Testing Guidelines
- Use table-driven tests
- Mock external dependencies
- Test error conditions
- Integration tests for database operations

## Documentation
- Package-level documentation for all packages
- Function documentation for exported functions
- README files for complex modules
- Service addition guide in `docs/`

## Performance Considerations
- Use connection pooling for database
- Implement proper timeouts
- Rate limiting for API endpoints
- Structured logging with appropriate levels

## Security Best Practices
- Input validation using validator package
- SQL injection prevention with parameterized queries
- Rate limiting configuration
- Secure headers middleware
- Password hashing with bcrypt

## Development Workflow
1. Define domain models in proto package
2. Implement service interface
3. Create persistence layer with SQL queries
4. Add configuration support
5. Update Wire dependency injection
6. Create REST endpoints
7. Add comprehensive tests
8. Update documentation

## Code Style
- Use gofmt for formatting
- Follow Go naming conventions
- Keep functions small and focused
- Use meaningful variable names
- Group related functionality
- Minimize package dependencies
